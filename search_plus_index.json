{"./":{"url":"./","title":"关于本文档","keywords":"","body":"notes 学习笔记整理 git win下创建.gitignore文件 同时推送到多个仓库 php PHP日志实现分析 通过url 读取网页内容 实现四种基本排序算法 http分块输出 PDO_Mysql Mysql 导入导出 创建/删除数据库 CURD简介 "},"git/git.html":{"url":"git/git.html","title":"git笔记","keywords":"","body":"git使用技巧 win下创建.gitignore文件 创建一个1.txt(可随意命名) cmd进入当前文件夹，输入命令 ren 1.txt .gitignore 同时推送到多个仓库 修改./git/conf文件，增加remote下url 运行git push -f origin master origin就是对应的remote名字 强制本地更新到远端 接着就正常使用了[remote \"origin\"] url = git@github.com:klauspeng/cc.git url = git@git.oschina.net:klauspeng/cc.git github host # GitHub Start 192.30.253.112 github.com 192.30.253.119 gist.github.com 151.101.100.133 assets-cdn.github.com 151.101.100.133 raw.githubusercontent.com 151.101.100.133 gist.githubusercontent.com 151.101.100.133 cloud.githubusercontent.com 151.101.100.133 camo.githubusercontent.com 151.101.100.133 avatars0.githubusercontent.com 151.101.100.133 avatars1.githubusercontent.com 151.101.100.133 avatars2.githubusercontent.com 151.101.100.133 avatars3.githubusercontent.com 151.101.100.133 avatars4.githubusercontent.com 151.101.100.133 avatars5.githubusercontent.com 151.101.100.133 avatars6.githubusercontent.com 151.101.100.133 avatars7.githubusercontent.com 151.101.100.133 avatars8.githubusercontent.com # GitHub End gitpage hexo环境搭建 "},"git/gitbook.html":{"url":"git/gitbook.html","title":"gitbook","keywords":"","body":"参考链接 gh-pages gitbook 文档 插件 "},"php/phpstorm/phpstorm.html":{"url":"php/phpstorm/phpstorm.html","title":"phpstorm","keywords":"","body":"PHPStorm 常用配置及问题 设置Terminal字体 在Editor->Colors & Fonts -> Console Font设置 取消注释斜体 参考文章 多个项目不同版本控制 File->settings->Version Control->点➕，添加对应的项目即可 git设置 Path to Git executable:D:\\Program Files (x86)\\Git\\cmd\\git.exe ssh: settings-->Version Control-->Git ,and then, In the SSH executable dropdown, choose Native 激活 参考文章 单行注释设置 方法里面的单行注释我喜欢，根据方法缩进，并且与//之后有一个空格，有点强迫症，哈哈！ 设置如下： Setting->Editor->Code Style->PHP->Wrapping and Braces->勾选掉Comment at first column Setting->Editor->Code Style->PHP->Other->Comment Code->勾选掉Line comment at first column，并勾选中Add a space at comment start 效果如下： 快捷键 快捷键 功能 备注 Ctrl+Alt+O 去除无用use,让代码更整洁 插件 翻译插件 "},"php/composer.html":{"url":"php/composer.html","title":"composer","keywords":"","body":"composer笔记 官网 简介 依赖管理，不是包管理器声明依赖关系： 创建composer.json的文件 { \"require\": { \"monolog/monolog\": \"1.2.*\" } } 运行composer install即可 自动加载 除了库的下载，Composer 还准备了一个自动加载文件，它可以加载 Composer 下载的库中所有的类文件。使用它，你只需要将下面这行代码添加到你项目的引导文件中： require 'vendor/autoload.php'; 命令行 初始化 init - - 参数 安装 install - - 参数 更新 update - - 参数 申明依赖 require - - 参数 全局执行 global 搜索 search - - 参数 展示 show - - 参数 依赖性检测 depends - - 参数 有效性检测 validate 依赖包状态检测 status 自我更新 self-update - - 参数 更改配置 config - - 使用方法 - - 参数 - - 修改包来源 创建项目 create-project - - 参数 打印自动加载索引 dump-autoload - - 参数 查看许可协议 licenses 执行脚本 run-script 诊断 diagnose 归档 archive - - 参数 获取帮助信息 help 包版本 名称 实例 确切版本号 1.0.2 区间 >=1.0, 通配符 1.0.* 相当于 >=1.0, 赋值运算符 ~1.2 相当于 >=1.2, (指定最低版本,允许版本号的最后一位数字上升) ^0.3 相当于 >=0.3.0, 优化自动加载 composer dump-autoload --optimize 转换 PSR-0/4 autoloading 到 classmap 可以获得更快的加载支持。 特别是在生产环境下建议这么做，但由于运行需要一些时间，因此并没有作为默认值。 全局配置镜像 官方： composer config -g repo.packagist composer https://packagist.org 中国： composer config -g repo.packagist composer https://packagist.phpcomposer.com 增加自定义命名空间 \"autoload\": { \"psr-4\" : { \"Commands\\\\\" : \"app/commands\" }, \"psr-0\" : { \"Commands\" : \"app/commands\" } } 运行命令：composer dumpautoload 自动引入文件 \"autoload\": { \"files\" : { \"/path/to/file/function.php\" } } "},"php/log.html":{"url":"php/log.html","title":"log","keywords":"","body":"PHP日志 PHP自带 error_log bool error_log ( string $message [, int $message_type = 0 [, string $destination [, string $extra_headers ]]] ) 把错误信息发送到 web 服务器的错误日志，或者到一个文件里。 message_type: 0.PHP日志 1.发送到destination设置的邮件地址 3.被发送到位置为destination的文件里 4.直接发送到SAPI的日志处理程序中 // 如果无法连接到数据库，发送通知到服务器日志 if (!Ora_Logon($username, $password)) { error_log(\"Oracle database not available!\", 0); } // 如果用尽了 FOO，通过邮件通知管理员 if (!($foo = allocate_new_foo())) { error_log(\"Big trouble, we're all out of FOOs!\", 1, \"operator@example.com\"); } // 调用 error_log() 的另一种方式: error_log(\"You messed up!\", 3, \"/var/tmp/my-errors.log\"); file_put_contents 刚好看到这个函数,这个函数也能写入文件啊,而且没必要YII那么复杂吧 比如：file_put_contents($file, $content.PHP_EOL, FILE_APPEND | LOCK_EX); 还实现了文件锁，哈哈，正好在研究文件锁。自己写了个,不断优化吧…… function logWrite($conteent, $level = 'DEBUG',$file = 'temp.txt') { $time = date('Y-m-d H:i:s',time()); $level = sprintf('%6s', $level); if (empty($conteent)) return false; if (is_array($conteent)) $conteent = json_encode($conteent,JSON_UNESCAPED_UNICODE); file_put_contents($file, $time.$level.' '.$conteent.PHP_EOL, FILE_APPEND | LOCK_EX); return true; } 结果： 2017-06-01 09:43:49 DEBUG {\"test\":\"我我我\",\"test1\":\"我我我\",\"test2\":\"我我我\",\"test3\":\"阿斯达奥撒多撒多撒多撒大所多所大所大大所多撒大\"} 2017-06-01 09:43:49 INFO {\"test\":\"我我我\",\"test1\":\"我我我\",\"test2\":\"我我我\",\"test3\":\"阿斯达奥撒多撒多撒多撒大所多所大所大大所多撒大\"} 2017-06-01 09:43:49 WARN {\"test\":\"我我我\",\"test1\":\"我我我\",\"test2\":\"我我我\",\"test3\":\"阿斯达奥撒多撒多撒多撒大所多所大所大大所多撒大\"} 2017-06-01 09:43:49 ERROR {\"test\":\"我我我\",\"test1\":\"我我我\",\"test2\":\"我我我\",\"test3\":\"阿斯达奥撒多撒多撒多撒大所多所大所大大所多撒大\"} 2017-06-01 09:44:15 DEBUG {\"test\":\"阿斯达萨达撒大所多撒多撒多撒大所多\",\"test1\":\"娃娃二群无多无群\",\"test2\":\"ADASD\",\"test3\":\"阿斯达奥撒多撒多撒多撒大所多所大所大大所多撒大\"} 2017-06-01 09:44:15 INFO {\"test\":\"阿斯达萨达撒大所多撒多撒多撒大所多\",\"test1\":\"娃娃二群无多无群\",\"test2\":\"ADASD\",\"test3\":\"阿斯达奥撒多撒多撒多撒大所多所大所大大所多撒大\"} 2017-06-01 09:44:15 WARN {\"test\":\"阿斯达萨达撒大所多撒多撒多撒大所多\",\"test1\":\"娃娃二群无多无群\",\"test2\":\"ADASD\",\"test3\":\"阿斯达奥撒多撒多撒多撒大所多所大所大大所多撒大\"} 2017-06-01 09:44:15 ERROR {\"test\":\"阿斯达萨达撒大所多撒多撒多撒大所多\",\"test1\":\"娃娃二群无多无群\",\"test2\":\"ADASD\",\"test3\":\"阿斯达奥撒多撒多撒多撒大所多所大所大大所多撒大\"} 2017-06-01 09:47:42 DEBUG 阿斯达萨达撒大所多撒多撒多撒大所多 2017-06-01 09:47:42 INFO 阿斯达萨达撒大所多撒多撒多撒大所多 2017-06-01 09:47:42 WARN 阿斯达萨达撒大所多撒多撒多撒大所多 2017-06-01 09:47:42 ERROR 阿斯达萨达撒大所多撒多撒多撒大所多 Monolog Github传送门 Monolog works with PHP 7.0 or above, use Monolog ^1.0 for PHP 5.3+ support. 8个级别：debug, info, notice, warning, error, critical, alert, emergency 支持firePHP,chromePHP调试,浏览器输出 支持redis,socket,数据库,文件流等写入 use Monolog\\Logger; use Monolog\\Handler\\StreamHandler; use Monolog\\Handler\\ChromePHPHandler; use Monolog\\Formatter\\LineFormatter; // Create some handlers $stream = new StreamHandler(__DIR__.'/my_app.log'); // 设置格式 // the default output format is \"[%datetime%] %channel%.%level_name%: %message% %context% %extra%\\n\" $output = \"[%datetime%] > %level_name% > %message% %context% %extra%\\n\"; // finally, create a formatter $formatter = new LineFormatter($output); $stream->setFormatter($formatter); // Create the main logger of the app $logger = new Logger('my_logger'); $logger->pushHandler($stream); $logger->pushHandler(new ChromePHPHandler()); $logger->error('12121'); $logger->warn('这是警告信息！'); // Or clone the first one to only change the channel $securityLogger = $logger->withName('security'); $securityLogger->error('12121'); $securityLogger->warn('这是警告信息！'); thinkphp5.0.9的Log File驱动也是用的error_log函数 protected function write($message, $destination, $apart = false) { //检测日志文件大小，超过配置大小则备份日志文件重新生成 if (is_file($destination) && floor($this->config['file_size']) writed[$destination] = false; } ...... return error_log($message, 3, $destination); } YII2.0.11的Log File驱动：用的是fwrite和file_put_contents /** * Writes log messages to a file. * @throws InvalidConfigException if unable to open the log file for writing */ public function export() { $text = implode(\"\\n\", array_map([$this, 'formatMessage'], $this->messages)) . \"\\n\"; if (($fp = @fopen($this->logFile, 'a')) === false) { throw new InvalidConfigException(\"Unable to append to log file: {$this->logFile}\"); } @flock($fp, LOCK_EX); if ($this->enableRotation) { // clear stat cache to ensure getting the real current file size and not a cached one // this may result in rotating twice when cached file size is used on subsequent calls clearstatcache(); } if ($this->enableRotation && @filesize($this->logFile) > $this->maxFileSize * 1024) { $this->rotateFiles(); @flock($fp, LOCK_UN); @fclose($fp); @file_put_contents($this->logFile, $text, FILE_APPEND | LOCK_EX); } else { @fwrite($fp, $text); @flock($fp, LOCK_UN); @fclose($fp); } if ($this->fileMode !== null) { @chmod($this->logFile, $this->fileMode); } } laravel5.4 用的是Monolog "},"php/Modern PHP.html":{"url":"php/Modern PHP.html","title":"Modern PHP","keywords":"","body":"Modern PHP笔记 第一部分 语言特性 命名空间 作用是按照一种虚拟的层次结构组织PHP代码，类似文件系统中的目录结构 主要解决命名冲突 声明： 第一行,namespace,用\\来声明子命名空间 导入和别名： 全局命名空间 在命名空间中使用全局函数，用\\前缀，提升效率 接口 灵活，委托别人实现细节 性状trait 生成器 闭包 就是匿名函数，对象 良好实践 标准 PHP-FIG 实现框架的互操作性接口、自动加载、风格 PSR-1:基本代码风格 PSR-2:严格的代码风格 PSR-3:日志记录接口 PSR-4:自动加载 .markdown-body{font-family: \"Microsoft YaHei\";} .markdown-body h1{text-align: center;} .markdown-body h3{font-weight:normal;color:blue;} .markdown-body h4{font-weight:normal;color:dodgerblue ;} "},"php/php.html":{"url":"php/php.html","title":"php基础","keywords":"","body":"php整理 三元运算符 $output = $value ? $value : 'No value set.'; //可简化成 $output = $value ?: 'No value set.'; 同理 $value = $value . $other_value; //可简化 $value .= $other_value; 运行时间统计示例 /** * Simple function to replicate PHP 5 behaviour */ function microtime_float() { list($usec, $sec) = explode(\" \", microtime()); return ((float)$usec + (float)$sec); } $time_start = microtime_float(); // Sleep for a while usleep(100); $time_end = microtime_float(); $time = $time_end - $time_start; echo \"Did nothing in $time seconds\\n\"; isset() empty() isset()检测变量是否设置 若变量存在且值不为NULL，则返回 TURE 同时检查多个变量时，每个单项都符合上一条要求时才返回 TRUE，否则结果为 FALSE 检测常量是否已设置可使用 defined() 函数empty()检查一个变量是否为空 若变量不存在则返回 TRUE 若变量存在且其值为\"\"、0、\"0\"、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 TURE 若变量存在且值不为\"\"、0、\"0\"、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 FALSE 二者区别 empty()和isset()的处理对象无外乎未定义变量，0，空字符串。 如果变量为0，则empty()会返回TRUE，isset()会返回TRUE； 如果变量为空字符串，则empty()会返回TRUE，isset()会返回TRUE； 如果变量未定义，则empty()会返回TRUE，isset()会返回FLASE； echo(),print(),print_r()的区别 echo是PHP语句（速度相对会快）, print和print_r是函数,语句没有返回值,函数可以有返回值(即便没有用) print只能打印出简单类型变量的值(如int,string) print_r可以打印出复杂类型变量的值(如数组,对象) echo -- 输出一个或者多个字符串 session与cookie区别 session与cookie的区别? session:储存用户访问的全局唯一变量,存储在服务器上的php指定的目录中的（session_dir）的位置进行的存放 cookie:用来存储连续访问一个页面时所使用，是存储在客户端，对于Cookie来说是存储在用户WIN的Temp目录中的。 两者都可通过时间来设置时间长短 通过设置session.use_trans_sid = 1，防止禁用cookie后session不能使用，会自动拼接session_id到href里面 获取session_id用 session_id(); 方法 写出 SQL语句的格式 : 插入 ，更新 ，删除 insert into user values (2,\"pthlp\",\"1990-12-03 00:00:00\"); update user set birth=now() where name = 'lp'; delete from user where name = 'lp'; 遍历一个文件夹下的所有文件和子文件夹 function read_all_dir( $dir ){ $result = array(); $handle = opendir($dir); if ( $handle ){ while ( ( $file = readdir($handle)) !== false ){ if ( $file != '.' && $file != '..'){ $cur_path = $dir . DIRECTORY_SEPARATOR . $file; if ( is_dir ( $cur_path ) ){ $result['dir'][$cur_path] = read_all_dir ( $cur_path );//递归 }else{ $result['file'][] = $cur_path; } } } closedir($handle); } return $result; } php 通过url 读取网页内容 方法1$text = file_get_contents($URL); 方法2、//获得url地址的网页内容 function get_URL($url){ $ch = curl_init(); $timeout = 5; curl_setopt($ch, CURLOPT_URL,$url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $timeout); $file_contents = curl_exec($ch); curl_close($ch); return $file_contents; } $text = get_URL($URL); 方法3$handle = fopen(\"http://s.jb51.net\", \"rb\"); $contents = stream_get_contents($handle); fclose($handle); echo $contents; 用户表与登录表分开的好处? 面向象面考虑,用户信息用户用户名密码进门钥匙 性能面考虑,数据检索候列少要快些且密码东西登录进没用,用户经常登录，但个人信息相对会少更改查看 安全性考虑，模块查询用户信息直接密码带容易现恶意操作 缓存，问了memcache与redis的区别，redis的优势之处。怎样解决memcache命中率低的问题，问了在实际项目中memcache命中率。是否部署过redis服务器。 有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？ 分析：兔子的规律为数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ... 所以很明显兔子数量为斐波那契数列，下面只需要用代码计算斐波那契数列即可。 function Fibonacci($month) { if ($month == 1 || $month == 2) { return 1; }else{ return Fibonacci($month-1)+ Fibonacci($month - 2); } } for ($i=1; $i '; } PHP实现四种基本排序算法 冒泡排序 思路分析：在要排序的一组数中，对当前还未排好的序列，从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。 $arr=array(1,43,54,62,21,66,32,78,36,76,39); bubbleSort($arr); //Array(1,21,32,36,39,43,54,62,66,76,78) function bubbleSort($arr) { $len=count($arr); //该层循环控制 需要冒泡的轮数 for($i=1;$i$arr[$k+1]) { $tmp=$arr[$k+1]; $arr[$k+1]=$arr[$k]; $arr[$k]=$tmp; } } } return $arr; } 选择排序 思路分析：在要排序的一组数中，选出最小的一个数与第一个位置的数交换。然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 function selectSort($arr) { //双重循环完成，外层控制轮数，内层控制比较次数 $len=count($arr); for($i=0; $i $arr[$j]) { //比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。 $p = $j; } } //已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。 if($p != $i) { $tmp = $arr[$p]; $arr[$p] = $arr[$i]; $arr[$i] = $tmp; } } //返回最终结果 return $arr; } 插入排序 思路分析：在要排序的一组数中，假设前面的数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。 function insertSort($arr) { $len=count($arr); for($i=1, $i=0;$j--) { if($tmp 快速排序 思路分析：选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。 function quickSort($arr) { //先判断是否需要继续进行 $length = count($arr); if($length $arr[$i]) { //放入左边数组 $left_array[] = $arr[$i]; } else { //放入右边 $right_array[] = $arr[$i]; } } //再分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数 $left_array = quick_sort($left_array); $right_array = quick_sort($right_array); //合并 return array_merge($left_array, array($base_num), $right_array); } 两个路径预定义常量 separator：分隔符 DIRECTORY_SEPARATOR DIRECTORY_SEPARATOR：路径分隔符，linux上就是‘/' windows上是‘\\' PATH_SEPARATOR PATH_SEPARATOR：include多个路径使用，在windows下，当你要include多个路径的话，你要用”;”隔开，但在linux下就使用”:”隔开的。 这2个常量的使用能够避免不同平台的兼容性问题 多维数组var_dump展示不全 参考链接 在php.ini里的xdebug节点中，追加一下配置： ;最多孩子节点数 xdebug.var_display_max_children=128 ;最大字节数 xdebug.var_display_max_data=512 ;最大深度 xdebug.var_display_max_depth=5 http分块输出 参考链接 public function csv() { $content = array(\"我是文章题目\", \"我是文章简介\", \"我是章节索引\", \"我是章节内容\",); $buffer_size = 4096; foreach ($content as $c) { echo str_pad( \"$c\", $buffer_size); ob_flush(); flush(); sleep(1); //我们这里故意放慢节奏，等待一秒 } } 应用-csv大批量导出： 参考链接 fp || $this->fp = fopen('php://output', 'a'); } /** * 设置输出数据 * * @param $data 数组 * @param int $isDoubleDimension 是否为二维数组（默认是） */ public function setDate(array $data,$isDoubleDimension = 1) { if ($isDoubleDimension) { foreach ($data as $item) { $rows = array(); foreach ($item as &$export_obj) { $rows[] = iconv('utf-8', 'GB18030', $export_obj); } fputcsv($this->fp, $rows); } unset($export_data); } else { $rows = array(); foreach ($data as &$d) { $rows[] = iconv('utf-8', 'GB18030', $d); } unset($d); fputcsv($this->fp, $rows); } // http分块输出 ob_flush(); flush(); } } PSR规范 这边文章说的比较好，参考链接 生成唯一ID md5(uniqid(md5(microtime(true)),true)) 参考链接 php-resque github传送门 php-resque使用 PDO_Mysql 数据库抽象层 PDO 持久化连接： PDO::ATTR_PERSISTENT => true 必须在传递给 PDO 构造函数的驱动选项数组中设置 参数化查询 因为两次传输，前一次传一个sql模板，第二次传查询参数，会把第二步传入的参数只做查询参数处理， 不做语义解释，这样注入的条件就算执行了，也不会得到查询结果。 测试了一个例子： $dbh = new PDO('mysql:host=localhost;dbname=test', 'root', 'root'); $stmt = $dbh->prepare(\"INSERT INTO user (name, pass) VALUES (:name, :value)\"); $stmt->bindParam(':name', $name); $stmt->bindParam(':value', $value); // 插入一行 $name = 'one'; $value = 1; $stmt->execute(); // 用不同的值插入另一行 $name = \" three'); DROP TABLE table;--\"; $value = 2; $stmt->execute(); var_dump($stmt->errorInfo()); 执行结果： Image - mysql json_encode()不转义汉字 $json = json_encode('hehehas哈哈说得很好是121245',JSON_UNESCAPED_UNICODE);//必须PHP5.4+ echo $json; // \"hehehas哈哈说得很好是121245\" echo json_decode($json); // hehehas哈哈说得很好是121245 "},"php/日期函数.html":{"url":"php/日期函数.html","title":"日期函数","keywords":"","body":"日期函数整理 设置时区 date_default_timezone_set('Asia/Shanghai'); date_default_timezone_set('PRC'); strtotime int strtotime ( string $time [, int $now = time() ] ) $nextfriday=strtotime(\"next Friday\"); //下周五 $nextmonth=strtotime(\"+1 Month\"); //从今天开始计算一个月以后的时间 $lastchristmas=strtotime(\"-1 year dec 25\"); //去年圣诞节 echo strtotime(\"now\"), \"\\n\"; echo strtotime(\"10 September 2000\"), \"\\n\"; echo strtotime(\"+1 day\"), \"\\n\"; echo strtotime(\"+1 week\"), \"\\n\"; echo strtotime(\"+1 week 2 days 4 hours 2 seconds\"), \"\\n\"; echo strtotime(\"next Thursday\"), \"\\n\"; echo strtotime(\"last Monday\"), \"\\n\"; "}}